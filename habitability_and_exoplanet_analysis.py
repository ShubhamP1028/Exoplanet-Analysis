# -*- coding: utf-8 -*-
"""habitability and exoplanet analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/176XmiKz0vDVlpnU3wYvBkceR_i16CJrl
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from ctypes import alignment

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.preprocessing import LabelEncoder

df= pd.read_csv('data.csv')

"""Create habitability flags"""

print(df.columns.tolist())

df['radius_flag'] = df['koi_prad'].between(0.5, 1.5).astype(int)
df['temp_flag'] = df['koi_teq'].between(200, 320).astype(int)

if 'total_pos_diff' not in df.columns:
    # Check for necessary positional columns.
    required_cols = ['koi_dicco_mdec', 'koi_dikco_mdec', 'koi_dicco_msky', 'koi_dikco_msky']
    if all(col in df.columns for col in required_cols):
        # Compute absolute difference in declination
        df['pos_diff_mdec'] = (df['koi_dicco_mdec'] - df['koi_dikco_mdec']).abs()
        # Compute absolute difference in sky magnitude
        df['pos_diff_msky'] = (df['koi_dicco_msky'] - df['koi_dikco_msky']).abs()
        # Sum the two differences to create a combined metric
        df['total_pos_diff'] = df['pos_diff_mdec'] + df['pos_diff_msky']
    else:
        missing = [col for col in required_cols if col not in df.columns]
        raise KeyError(f"One or more required positional columns are missing: {missing}")
df['pos_flag'] = (df['total_pos_diff'] < 0.1).astype(int)

"""Calculate total habitability score"""

df['habitability_score'] = df['radius_flag'] + df['temp_flag'] + df['pos_flag']

"""Top 10 most habitable planets"""

habitable_df = df[df['habitability_score'] == 3]
print("Top habitability candidates:")
print(habitable_df[['kepoi_name', 'koi_prad', 'koi_teq', 'total_pos_diff', 'habitability_score']].head(10))

"""<b>Score 0: None of the criteria met.</b>

The planet does not fall within the accepted ranges for radius, equilibrium temperature, or positional consistency.

<b>Score 1: Only one criterion met.</b>

The planet meets just one of the conditions (either acceptable radius, temperature, or positional difference), indicating limited habitability potential.

<b>Score 2: Two out of three criteria met.</b>

The planet matches on two of the features, suggesting it could be considered moderately promising in terms of habitability.

<b>Score 3: All three criteria met.</b>

The planet falls within the ideal ranges for radius, equilibrium temperature, and has a low positional discrepancy, making it the strongest candidate based on these parameters.
"""

plt.figure(figsize=(4, 5))
ax = sns.countplot(x='habitability_score', data=df , color= 'purple')
# x_labels = ['Score 0: None of the criteria met.', 'Score 1: Only one criterion met.', 'Score 2: Two out of three criteria met.', 'Score 3: All three criteria met.']
plt.title("Distribution of Habitability Scores")
plt.xlabel("Habitability Scores")
plt.ylabel("Number of Planets")

for p in ax.patches:
    height = p.get_height()
    ax.text(p.get_x() + p.get_width() / 2., height + 0.5,
            int(height), ha="center", fontsize=10)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
scatter = sns.scatterplot(data=df, x='koi_prad', y='koi_teq', hue='habitability_score',
                          palette='viridis', s=100, edgecolor='k')

# Add reference lines for ideal habitability criteria:
plt.axvline(x=0.5, color='red', linestyle='--', label='Radius lower limit')
plt.axvline(x=1.5, color='green', linestyle='--', label='Radius upper limit')
plt.axhline(y=200, color='blue', linestyle='--', label='Temperature lower limit')
plt.axhline(y=320, color='purple', linestyle='--', label='Temperature upper limit')

plt.title("Habitability Mapping: Planet Radius vs. Equilibrium Temperature")
plt.xlabel("Planet Radius (Earth radii)")
plt.ylabel("Equilibrium Temperature (K)")
plt.legend(title='Habitability Score', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

feature_cols = ['koi_prad', 'koi_teq', 'total_pos_diff', 'avg_err_mdec', 'habitability_score']
X = df[feature_cols].dropna()
y = df.loc[X.index, 'koi_disposition'].astype(str)

le = LabelEncoder()
y_encoded = le.fit_transform(y)

X_train, X_test, y_train, y_test = train_test_split(X, y_encoded, test_size=0.2, random_state=42)

"""model trainnig"""

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

"""prediction testing/"""

y_pred = model.predict(X_test)

"""results"""

print("Classification Report:")
print(classification_report(y_test, y_pred, target_names=le.classes_))

"""Confusion matrix"""

conf_matrix = confusion_matrix(y_test, y_pred)
sns.heatmap(conf_matrix, annot=True, fmt='d', xticklabels=le.classes_, yticklabels=le.classes_)
plt.title("Confusion Matrix")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

"""<b>Candidate</b>

These are objects that exhibit signals suggesting the presence of an exoplanet (such as transit events), but they have not yet been fully confirmed through additional observations or rigorous statistical validation.

<b>Confirmed</b>

These exoplanet candidates have been validated as actual exoplanets through one or more methods (e.g., follow-up observations, radial velocity measurements, or statistical confirmation).

<b>False Positive</b>

These signals initially appeared to be indicative of exoplanets but were later determined to have other origins (for example, stellar variability, instrumental noise, or eclipsing binary systems).

<b>Not dispositioned</b>

These are objects for which a clear classification (candidate, confirmed, or false positive) has not been made yet. They might still be under review, or the data could be inconclusive.
"""

